/*
Copyright (c) 2015, Plume Design Inc. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
   1. Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
   2. Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
   3. Neither the name of the Plume Design Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Plume Design Inc. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/* * ===========================================================================
 *  DHCP Server driver for dnsmasq; should be used on OpenWRT and derivatives
 * ===========================================================================
 */
#include <sys/types.h>
#include <errno.h>
#include <fcntl.h>
#include <regex.h>

#include "ds_dlist.h"
#include "ds_tree.h"
#include "log.h"
#include "evx.h"
#include "util.h"
#include "daemon.h"
#include "os_file.h"
#include "os_regex.h"

#include "inet.h"
#include "inet_dhcps.h"
#include "kconfig.h"

#if !defined(CONFIG_USE_KCONFIG)

#define CONFIG_INET_DNSMASQ_PATH            "/usr/sbin/dnsmasq"
#define CONFIG_INET_DNSMASQ_LEASE_PATH      "/tmp/dhcp.leases"
#define CONFIG_INET_DNSMASQ_ETC_PATH        "/var/etc/dnsmasq.conf"
#define CONFIG_INET_DNSMASQ_PID_PATH        "/var/run/dnsmasq/dnsmasq.pid"

#endif /* CONFIG_USE_KCONFIG */

/* Debounce timer, the maximum amount time to wait before doing a full dnsmasq service restart */
#define DHCPS_DEBOUNCE_TIMER                0.5

static char dhcps_dnsmasq_conf_header[] =
    "#\n"
    "# Auto-generated by Plume\n"
    "#\n"
    "\n"
    "### Global section\n"
    "\n"
    "dhcp-authoritative\n"
    "domain-needed\n"
    "localise-queries\n"
    "read-ethers\n"
    "bogus-priv\n"
    "expand-hosts\n"
    "domain=lan\n"
    "server=/lan/\n"
    "dhcp-leasefile=/tmp/dhcp.leases\n"
    "resolv-file=/tmp/resolv.conf\n"
    "no-dhcp-interface=br-wan,eth0,eth1\n"
    "address=/plume.lan/192.168.1.1\n"
    "ptr-record=1.1.168.192.in-addr.arpa,plume.lan\n"
    //>>SIT-18: VU#598349
    "#dhcp-name-match=set:wpad-ignore,wpad\n"
    "#dhcp-ignore-names=tag:wpad-ignore\n"
    //<<SIT-18
    "# Disable thedefault gateway and DNS server options.\n"
    "# Cloud needs to set these explicitly.\n"
    "dhcp-option=3\n"
    "dhcp-option=6\n"
    "\n"
    "### Interface section\n"
    "\n";

struct dhcps_config
{
    inet_ip4addr_t                  ds_range_start;
    inet_ip4addr_t                  ds_range_end;
    double                          ds_lease_time;
    char                           *ds_opts[DHCP_OPTION_MAX];

    ds_tree_t                       ds_rip_list;
};

struct __inet_dhcps
{
    char                            ds_ifname[C_IFNAME_LEN];
    bool                            ds_enabled;
    ds_dlist_node_t                 ds_dnode;
    inet_dhcps_error_fn_t          *ds_error_fn;
    inet_dhcp_lease_fn_t           *ds_lease_notify_fn;
    inet_t                         *ds_lease_notify_inet;

    /*
     * Since dnsmasq start/stop is executed with a slgiht delay, we need to have
     * two copies of the configuration -- one that was used to start dnsmasq (active)
     * and one that the user is allowed to mess with (inactive).
     *
     * As soon as dhcps_start() is called, the inactive configuration is coped to the 
     * active one.
     */
    struct dhcps_config             ds_config_inactive;
    struct dhcps_config             ds_config_active;
};

/*
 * DHCP lease strcture -- this is used to hold cached information from the
 * lease file
 */
struct dhcps_lease
{
    struct inet_dhcp_lease_info     sl_lease;
    int                             sl_gencnt;
    ds_tree_node_t                  sl_node;
};

struct dhcps_rip
{
    inet_macaddr_t                  ds_macaddr;
    inet_ip4addr_t                  ds_ip4addr;
    char                           *ds_hostname;
    ds_tree_node_t                  ds_dnode;
};

/*
 * Static functions
 */
static void dhcps_delayed_restart();
static void __dhcps_delayed_restart(void);
static void __dhcps_delayed_event(EV_P_ ev_debounce *w, int revents);

static void dhcps_dispatch_error(void);
static bool dhcps_atexit(daemon_t *proc);

static void dhcps_config_free(struct dhcps_config *conf);
static void dhcps_config_copy(struct dhcps_config *dst, struct dhcps_config *src);

static void dhcps_lease_onchange(struct ev_loop *loop, ev_stat *w, int revent);
static bool dhcps_lease_send_event(struct dhcps_lease *dl, bool released);

static struct dhcps_rip *dhcps_rip_node_new(void);
static struct dhcps_rip *dhcps_rip_node_dup(const struct dhcps_rip *rip);
static void dhcps_rip_node_free(struct dhcps_rip *rip);
static int dhcps_rip_cmp(void *a, void *b);


/*
 * Globals
 */
static ds_dlist_t   dhcps_list = DS_DLIST_INIT(inet_dhcps_t, ds_dnode);
static daemon_t     dhcps_proc;
static ev_debounce  dhcps_debounce;

static ds_key_cmp_t dhcps_lease_cmp;
static ev_stat      dhcps_lease_watcher;
static int          dhcps_lease_gencnt = 0;
static ds_tree_t    dhcps_lease_list = DS_TREE_INIT(dhcps_lease_cmp, struct dhcps_lease, sl_node);

/*
 * ===========================================================================
 *  DNS server API
 * ===========================================================================
 */
bool inet_dhcps_init(inet_dhcps_t *self, const char *ifname)
{
    static bool dhcps_init = false;

    /* Initialize global variables */
    if (!dhcps_init)
    {
        LOG(INFO, "dhcps: Initializing global dnsmasq instance.");

        char *var_folders[] = { "/var/etc", "/var/run", "/var/run/dnsmasq", NULL };
        char **pvar;

        for (pvar = var_folders; *pvar != NULL; pvar++)
        {
            /* Create intermediate folders if they do not exists */
            if (mkdir(*pvar, 0755) != 0 && errno != EEXIST)
            {
                LOG(CRIT, "dnsmasq: Unable to create folder %s", *pvar);
                return false;
            }
        }

        if (!daemon_init(&dhcps_proc, CONFIG_INET_DNSMASQ_PATH, DAEMON_LOG_ALL))
        {
            LOG(CRIT, "dnsmasq: Error initializing global DNSMASQ daemon instance.");
            return false;
        }

        /* Set the PID file location -- necessary to kill stale instances */
        if (!daemon_pidfile_set(&dhcps_proc, CONFIG_INET_DNSMASQ_PID_PATH, false))
        {
            LOG(WARN, "dnsmasq: Error setting the PID file path.");
        }

        if (!daemon_restart_set(&dhcps_proc, true, 0.0, 0))
        {
            LOG(WARN, "dnsmasq: Error enabling daemon auto-restart on global instance.");
        }

        if (!daemon_atexit(&dhcps_proc, dhcps_atexit))
        {
            LOG(WARN, "dnsmasq: Error setting the atexit callback.");
        }

        /* Initialize arguments */
        daemon_arg_add(&dhcps_proc, "--keep-in-foreground");                /* Do not fork to background */
        daemon_arg_add(&dhcps_proc, "-C", CONFIG_INET_DNSMASQ_ETC_PATH);    /* Config file path */
        daemon_arg_add(&dhcps_proc, "-x", CONFIG_INET_DNSMASQ_PID_PATH);    /* PID file */

        ev_debounce_init(&dhcps_debounce, __dhcps_delayed_event, DHCPS_DEBOUNCE_TIMER);

        /* Initialize the DHCP leases file watcher */
        ev_stat_init(
                &dhcps_lease_watcher,
                dhcps_lease_onchange,
                CONFIG_INET_DNSMASQ_LEASE_PATH,
                0.0);

        dhcps_init = true;
#if defined(CONFIG_INET_DNSMASQ_KEEP_RUNNING)
        /* Start dnsmasq immediately */
        dhcps_delayed_restart();
#endif
    }

    /* Initialzie this instance */
    memset(self, 0 ,sizeof(*self));

    if (strscpy(self->ds_ifname, ifname, sizeof(self->ds_ifname)) < 0)
    {
        LOG(ERR, "dnsmasq: Error initializing instance for %s, interface name too long.", ifname);
        return false;
    }

    /* Initialize RIP (reserved IP) config lists:  */
    ds_tree_init(&self->ds_config_inactive.ds_rip_list, dhcps_rip_cmp,
                 struct dhcps_rip, ds_dnode);
    ds_tree_init(&self->ds_config_active.ds_rip_list, dhcps_rip_cmp,
                 struct dhcps_rip, ds_dnode);

    return true;
}

bool inet_dhcps_fini(inet_dhcps_t *self)
{
    bool retval = true;

    if (!inet_dhcps_stop(self))
    {
        LOG(ERR, "dhcps: Error stopping DHCPS instance.");
        retval = false;
    }

    dhcps_config_free(&self->ds_config_active);
    dhcps_config_free(&self->ds_config_inactive);

    return retval;
}

inet_dhcps_t *inet_dhcps_new(const char *ifname)
{
    inet_dhcps_t *self = calloc(1, sizeof(inet_dhcps_t));

    if (!inet_dhcps_init(self, ifname))
    {
        free(self);
        return NULL;
    }

    return self;
}

bool inet_dhcps_del(inet_dhcps_t *self)
{
    bool retval = inet_dhcps_fini(self);

    free(self);

    return retval;
}

bool inet_dhcps_start(inet_dhcps_t *self)
{
    if (INET_IP4ADDR_IS_ANY(self->ds_config_inactive.ds_range_start) ||
            INET_IP4ADDR_IS_ANY(self->ds_config_inactive.ds_range_end))
    {
        LOG(WARN, "dnsmasq: DHCP server will not start on interface %s. Configuration is incomplete.",
                self->ds_ifname);

        return false;
    }

    if (self->ds_enabled) return true;

    LOG(INFO, "dnsmasq: Starting DHCPS service on interface %s.", self->ds_ifname);

    /* Since the dnsmasq startup is delayed, some settings may change between a dhcps_start() and
     * the actual dnsmasq start.
     *
     * To avoid any races, copy the configuration 
     */
    dhcps_config_copy(&self->ds_config_active, &self->ds_config_inactive);

    self->ds_enabled = true;

    ds_dlist_insert_tail(&dhcps_list, self);

    dhcps_delayed_restart();

    return true;
}

bool inet_dhcps_stop(inet_dhcps_t *self)
{
    if (!self->ds_enabled) return true;

    LOG(INFO, "dnsmasq: Stopping DHCPS service on interface %s.", self->ds_ifname);

    ds_dlist_remove(&dhcps_list, self);

    self->ds_enabled = false;

    dhcps_delayed_restart();

    return true;
}

void inet_dhcps_error_fn(inet_dhcps_t *self, inet_dhcps_error_fn_t *fn)
{
    self->ds_error_fn = fn;
}

void inet_dhcps_lease_notify_set(inet_dhcps_t *self, inet_dhcp_lease_fn_t *fn, inet_t *inet)
{
    self->ds_lease_notify_fn = fn;
    self->ds_lease_notify_inet = inet;
}

/* Requires restart */
bool inet_dhcps_range(
        inet_dhcps_t *self,
        inet_ip4addr_t start,
        inet_ip4addr_t stop)
{
    memcpy(
            &self->ds_config_inactive.ds_range_start,
            &start,
            sizeof(self->ds_config_inactive.ds_range_start));

    memcpy(
            &self->ds_config_inactive.ds_range_end,
            &stop,
            sizeof(self->ds_config_inactive.ds_range_end));

    return true;
}

/* Requires restart */
bool inet_dhcps_lease(inet_dhcps_t *self, int lease_time_s)
{
    self->ds_config_inactive.ds_lease_time = lease_time_s;
    return true;
}

/* Requires restart */
bool inet_dhcps_option(
        inet_dhcps_t *self,
        enum inet_dhcp_option opt,
        const char *value)
{
    if (opt >= DHCP_OPTION_MAX) return false;

    if (self->ds_config_inactive.ds_opts[opt] != NULL)
    {
        free(self->ds_config_inactive.ds_opts[opt]);
        self->ds_config_inactive.ds_opts[opt] = NULL;
    }

    if (value != NULL)
    {
        self->ds_config_inactive.ds_opts[opt] = strdup(value);
    }

    return true;
}

/* Return the current value of an option */
const char *inet_dhcps_option_get(
        inet_dhcps_t *self,
        enum inet_dhcp_option opt)
{
    if (opt >= DHCP_OPTION_MAX) return NULL;

    return self->ds_config_inactive.ds_opts[opt];
}

/*
 * Perform a delayed restart of the dnsmasq service
 *
 * If multiple restarts are requested, only one shall be performed.
 */
void dhcps_delayed_restart(void)
{
    ev_debounce_start(EV_DEFAULT, &dhcps_debounce);
}

/**
 * Commit the global configuration and restart dhcpc
 */
static void __dhcps_delayed_event(EV_P_ ev_debounce *w, int revents)
{
    __dhcps_delayed_restart();
}

void __dhcps_delayed_restart(void)
{
    ds_dlist_iter_t iter;
    inet_dhcps_t *pds;
    struct dhcps_rip *rip;
    size_t hsz;
    int ii;

    FILE *fconf = NULL;
    bool status = false;
    bool have_config = false;

    LOG(INFO, "Restarting DNSMASQ ...");

    if (!daemon_stop(&dhcps_proc))
    {
        LOG(ERR, "Error stopping DNSMASQ ...");
        // goto exit;
    }

    if (ev_is_active(&dhcps_lease_watcher))
    {
        ev_stat_stop(EV_DEFAULT, &dhcps_lease_watcher);
    }

    /*
     * Write out the DNSMASQ configuration file
     */
    fconf = fopen(CONFIG_INET_DNSMASQ_ETC_PATH, "w");

    /* Write out the header */
    hsz = strlen(dhcps_dnsmasq_conf_header);
    if (fwrite(dhcps_dnsmasq_conf_header, 1, hsz, fconf) != hsz)
    {
        LOG(ERR, "dnsmasq: Error writing config file header.");
        goto exit;
    }

    /* Traverse all instances of dhcp_server_t and write their specific configs. */
    for (pds = ds_dlist_ifirst(&iter, &dhcps_list); pds != NULL; pds = ds_dlist_inext(&iter))
    {
        if (!pds->ds_enabled) continue;

        /* Write out the range */
        fprintf(fconf, "# Interface: %s\n", pds->ds_ifname);
#if 0
        /* XXX: Apparently the netmask is not needed -- this is one difference between NM1 */
#endif
        fprintf(fconf, "dhcp-range=%s,"PRI(inet_ip4addr_t)","PRI(inet_ip4addr_t),
                pds->ds_ifname,
                FMT(inet_ip4addr_t, pds->ds_config_active.ds_range_start),
                FMT(inet_ip4addr_t, pds->ds_config_active.ds_range_end));

        /* Append the lease time */
        if (pds->ds_config_active.ds_lease_time > 0.0)
        {
            /* XXX: NM1 converts this to hours and writes it to the config file with the "h" postfix */
            fprintf(fconf, ",%d", (int)pds->ds_config_active.ds_lease_time);
        }

        fprintf(fconf, "\n");

        for (ii = 0; ii < DHCP_OPTION_MAX; ii++)
        {
            if (pds->ds_config_active.ds_opts[ii] != NULL)
            {
                fprintf(fconf, "dhcp-option=%s,%d,%s\n", pds->ds_ifname, ii, pds->ds_config_active.ds_opts[ii]);
            }
        }

        /* Reserved IPs section:  */
        ds_tree_foreach(&pds->ds_config_active.ds_rip_list, rip)
        {
            if (rip->ds_hostname)
            {
                fprintf(fconf, "dhcp-host="PRI_inet_macaddr_t",%s,"
                        PRI_inet_ip4addr_t"\n",
                        FMT_inet_macaddr_t(rip->ds_macaddr), rip->ds_hostname,
                        FMT_inet_ip4addr_t(rip->ds_ip4addr));
            }
            else
            {
                fprintf(fconf, "dhcp-host="PRI_inet_macaddr_t","
                        PRI_inet_ip4addr_t"\n",
                        FMT_inet_macaddr_t(rip->ds_macaddr),
                        FMT_inet_ip4addr_t(rip->ds_ip4addr));
            }
        }
        fprintf(fconf, "# End: %s\n\n", pds->ds_ifname);

        have_config = true;
    }

    fprintf(fconf, "### End Interface\n");

    fflush(fconf);

    if (have_config || kconfig_enabled(CONFIG_INET_DNSMASQ_KEEP_RUNNING))
    {
        ev_stat_start(EV_DEFAULT, &dhcps_lease_watcher);

        /* Trigger an update event right away */
        dhcps_lease_onchange(EV_DEFAULT, &dhcps_lease_watcher, 0);

        if (!daemon_start(&dhcps_proc))
        {
            LOG(ERR, "dnsmasq: Error starting daemon.");
            goto exit;
        }
    }

    status = true;

exit:
    if (fconf != NULL) fclose(fconf);

    if (!status)
    {
        /* Propagate the error */
        dhcps_dispatch_error();
    }
}

/**
 * Propagate the error to all registered instances of dhcp_server_t; this
 * is mainly used when a fatal error occurs which prevents dnsmasq from
 * running.
 */
void dhcps_dispatch_error(void)
{
    inet_dhcps_t *ds;

    ds_dlist_iter_t iter;

    for (ds = ds_dlist_ifirst(&iter, &dhcps_list); ds != NULL; ds = ds_dlist_inext(&iter))
    {
        if (!ds->ds_enabled) continue;
        if (ds->ds_error_fn == NULL) continue;

        ds->ds_error_fn(ds);
    }
}

/* damon_atexit() handler -- dispatches error to all active instances */
bool dhcps_atexit(daemon_t *proc)
{
    LOG(ERR, "dnsmasq: Global instance failed to start.");

    dhcps_dispatch_error();

    return true;
}


void dhcps_config_free(struct dhcps_config *conf)
{
    int ii;
    struct dhcps_rip *rip = 0;

    for (ii = 0; ii < DHCP_OPTION_MAX; ii++)
    {
        if (conf->ds_opts[ii] != NULL)
        {
            free(conf->ds_opts[ii]);
            conf->ds_opts[ii] = NULL;
        }
    }

    while ( (rip = ds_tree_remove_head(&conf->ds_rip_list)))
    {
        dhcps_rip_node_free(rip);
    }
}

void dhcps_config_copy(
        struct dhcps_config *dest,
        struct dhcps_config *src)
{
    int ii;
    struct dhcps_rip *rip;
    struct dhcps_rip *rip_new;

    memcpy(dest, src, sizeof(*dest));

    for (ii = 0; ii < DHCP_OPTION_MAX; ii++)
    {
        dest->ds_opts[ii] = NULL;

        if (src->ds_opts[ii] != NULL)
        {
            dest->ds_opts[ii] = strdup(src->ds_opts[ii]);
        }
   }

    ds_tree_init(&dest->ds_rip_list, dhcps_rip_cmp,
                 struct dhcps_rip, ds_dnode);

    ds_tree_foreach(&src->ds_rip_list, rip)
    {
        rip_new = dhcps_rip_node_dup(rip);

        ds_tree_insert(&dest->ds_rip_list, rip_new, &rip_new->ds_macaddr);
    }
}

/*
 * ===========================================================================
 *  DHCP lease handling
 * ===========================================================================
 */

/*
 * Return an integer less than, equal to, or greater than zero if a is less than,
 * equal to, or greater than b.
 *
 * The fields used for comparison are the MAC and IP addresses. These two should
 * identify an unique lease entry.
 */
int dhcps_lease_cmp(void *_a, void *_b)
{
    int rc;

    struct inet_dhcp_lease_info *a = _a;
    struct inet_dhcp_lease_info *b = _b;

    /* Compare MAC addresses */
    rc = memcmp(&a->dl_hwaddr, &b->dl_hwaddr, sizeof(a->dl_hwaddr));
    if (rc != 0) return rc;

    /* Compare IP addresses */
    rc = memcmp(&a->dl_ipaddr, &b->dl_ipaddr, sizeof(a->dl_ipaddr));
    if (rc != 0) return rc;

    return 0;
}

/*
 * Send a lease acquired/release notification event to the appropriate DHCP server instance
 *
 * Returns false if the instance doesn't exists or if the callback failed
 */
bool dhcps_lease_send_event(struct dhcps_lease *dl, bool released)
{
    inet_dhcps_t *pds;
    ds_dlist_iter_t iter;

    for (pds = ds_dlist_ifirst(&iter, &dhcps_list); pds != NULL; pds = ds_dlist_inext(&iter))
    {
        /* Check if the IP is inside the DHCP server reservation list range */
        if (inet_ip4addr_cmp(&dl->sl_lease.dl_ipaddr, &pds->ds_config_active.ds_range_start) >= 0 &&
            inet_ip4addr_cmp(&dl->sl_lease.dl_ipaddr, &pds->ds_config_active.ds_range_end) <= 0)
        {
            break;
        }
    }

    if (pds == NULL)
    {
        LOG(WARN, "dnsmasq: No DHCP server instance has an IP range that matches "PRI(inet_ip4addr_t)".",
                FMT(inet_ip4addr_t, dl->sl_lease.dl_ipaddr));

        return false;
    }

    /* The lease time in is not present in /tmp/dhcp.leases -- copy it from the DHCP server configuration */
    dl->sl_lease.dl_leasetime = pds->ds_config_active.ds_lease_time;

    /* Dispatch the event */
    if (pds->ds_lease_notify_fn == NULL)
    {
        return false;
    }

    return pds->ds_lease_notify_fn(
                pds->ds_lease_notify_inet,
                released,
                &dl->sl_lease);
}

/*
 * Compare lease @p dl with the current lease cache and issue update/delete events
 */
bool dhcps_lease_update(struct dhcps_lease *dl)
{
    bool dl_update = false;
    struct dhcps_lease *ndl = NULL;

    ndl = ds_tree_find(&dhcps_lease_list, &dl->sl_lease);
    if (ndl == NULL)
    {
        /* New lease */
        ndl = calloc(1, sizeof(*ndl));
        memcpy(ndl, dl, sizeof(*ndl));

        ds_tree_insert(&dhcps_lease_list, ndl, &ndl->sl_lease);

        dl_update = true;
    }
    else
    {
        /*
         * Compare fields
         */
        if (inet_ip4addr_cmp(&ndl->sl_lease.dl_ipaddr, &dl->sl_lease.dl_ipaddr) != 0)
        {
            ndl->sl_lease.dl_ipaddr = dl->sl_lease.dl_ipaddr;
            dl_update = true;
        }

        if (strcmp(ndl->sl_lease.dl_hostname, dl->sl_lease.dl_hostname) != 0)
        {
            strscpy(ndl->sl_lease.dl_hostname, dl->sl_lease.dl_hostname, sizeof(ndl->sl_lease.dl_hostname));
            dl_update = true;
        }

        if (strcmp(ndl->sl_lease.dl_fingerprint, dl->sl_lease.dl_fingerprint) != 0)
        {
            strscpy(ndl->sl_lease.dl_fingerprint, dl->sl_lease.dl_fingerprint, sizeof(ndl->sl_lease.dl_fingerprint));
            dl_update = true;
        }

        if (strcmp(ndl->sl_lease.dl_vendorclass, dl->sl_lease.dl_vendorclass) != 0)
        {
            strscpy(ndl->sl_lease.dl_vendorclass, dl->sl_lease.dl_vendorclass, sizeof(ndl->sl_lease.dl_vendorclass));
            dl_update = true;
        }
    }

    if (dl_update)
    {
        dhcps_lease_send_event(dl, false);
    }

    ndl->sl_gencnt = dhcps_lease_gencnt;

    return dl_update;
}

/*
 * Flush all leases that were not updated since the last call to dhcps_lease_flush()
 */
void dhcps_lease_flush(void)
{
    ds_tree_iter_t iter;
    struct dhcps_lease *dl;

    for (dl = ds_tree_ifirst(&iter, &dhcps_lease_list); dl != NULL; dl = ds_tree_inext(&iter))
    {
        if (dl->sl_gencnt != dhcps_lease_gencnt)
        {
            ds_tree_iremove(&iter);

            /* Send the event notification */
            dhcps_lease_send_event(dl, true);

            memset(dl, 0, sizeof(*dl));
            free(dl);
        }
    }

    /* Increase the generation count */
    dhcps_lease_gencnt++;
}

/* Parse a DNSMASQ lease line and convert it to a DHCP cache entry structure */
bool __dhcps_lease_parse_line(struct dhcps_lease *dl, const char *line)
{
    /*
     * Regular expression to match a line in the "dhcp.lease" file of the
     * following format:
     *
     * 1461412276 f4:09:d8:89:54:4f 192.168.0.181 android-c992b284e24fdd69 1,33,3,6,15,28,51,58,59 "dhcpc-1.1:ARMv4" 01:f4:09:d8:89:54:4f
     */
    static const char dhcp_lease_parse_re[] =
        "^[0-9]+ "                              /* Match timestamp */
        "(([a-fA-F0-9]{2}:?){6}) "              /* 1,2: Match MAC address */
        "(([0-9]+\\.?){4}) "                    /* 3,4: Match IP address */
        "(\\*|[a-zA-Z0-9_-]+) "                 /* 5: Match hostname, can be "*" */
        "(\\*|([0-9]+,?)+) "                    /* 6,7: Match fingerprint, can be "*" */
        "\"(\\*|[^\"]+)\" "                     /* 8: Match vendor-class, can be "*" */
        "[^ ]+$";                               /* Match CID, can be "*" */

    static bool parse_re_compiled = false;
    static regex_t parse_re;

    char shwaddr[C_MACADDR_LEN];
    char sipaddr[C_IP4ADDR_LEN];

    regmatch_t rm[9];

    if (!parse_re_compiled && regcomp(&parse_re, dhcp_lease_parse_re, REG_EXTENDED) != 0)
    {
        LOG(ERR, "dnsmasq: Error compiling DHCP lease parsing regular expression.");
        return false;
    }

    parse_re_compiled = true;

    /* Parse the lease line using regular expressions */
    if (regexec(&parse_re, line, ARRAY_LEN(rm), rm, 0) != 0)
    {
        LOG(ERR, "NM: Invalid DHCP lease line (ignoring): %s", line);
        return false;
    }

    memset(dl, 0, sizeof(*dl));

    /* Extract the data */
    os_reg_match_cpy(
            shwaddr,
            sizeof(shwaddr),
            line,
            rm[1]);

    os_reg_match_cpy(
            sipaddr,
            sizeof(sipaddr),
            line, rm[3]);

    os_reg_match_cpy(dl->sl_lease.dl_hostname,
            sizeof(dl->sl_lease.dl_hostname),
            line,
            rm[5]);

    /* Copy the fingerprint */
    os_reg_match_cpy(dl->sl_lease.dl_fingerprint,
            sizeof(dl->sl_lease.dl_fingerprint),
            line,
            rm[6]);

    /* Copy the vendor-class */
    os_reg_match_cpy(dl->sl_lease.dl_vendorclass,
            sizeof(dl->sl_lease.dl_vendorclass),
            line,
            rm[8]);


    if (!inet_macaddr_fromstr(&dl->sl_lease.dl_hwaddr, shwaddr))
    {
        LOG(ERR, "NM: Invalid DHCP MAC address obtained from lease file: %s", shwaddr);
        return false;
    }

    if (!inet_ip4addr_fromstr(&dl->sl_lease.dl_ipaddr, sipaddr))
    {
        LOG(ERR, "NM: Invalid DHCP IPv4 address obtained from lease file: %s", sipaddr);
        return false;
    }

    return true;
}


bool dhcps_lease_parse(void)
{
    char line[1024];

    FILE *lf = NULL;
    bool retval = false;

    lf = fopen(CONFIG_INET_DNSMASQ_LEASE_PATH, "r");
    if (lf == NULL)
    {
        LOG(ERR, "dnsmasq: Error opening lease file: %s", CONFIG_INET_DNSMASQ_LEASE_PATH);
        goto exit;
    }

    /*
     * Lock the file -- dnsmasq was patched to to the same -- this ensures we're
     * not reaidng a half-written file.
     *
     * When the file descriptor is closed, the assiociated lock should be released
     * as well.
     */
    if (!os_file_lock(fileno(lf), OS_LOCK_READ))
    {
        LOG(ERR, "dnsmasq: Error locking lease file: %s", CONFIG_INET_DNSMASQ_LEASE_PATH);
        goto exit;
    }

    while (fgets(line, sizeof(line), lf) != NULL)
    {
        struct dhcps_lease dl;

        if (!__dhcps_lease_parse_line(&dl, line))
        {
            LOG(WARN, "dnsmasq: Error parsing DHCP lease line: %s", line);
            continue;
        }

        dhcps_lease_update(&dl);
    }

    retval = true;
exit:
    if (lf != NULL) fclose(lf);

    return retval;
}

/*
 * Callback function triggered by file status change on the lease file
 */
void dhcps_lease_onchange(struct ev_loop *loop, ev_stat *w, int revent)
{
    if (w->attr.st_nlink)
    {
        LOG(INFO, "dnsmasq: Lease file changed.");
        dhcps_lease_parse();
    }
    else
    {
        LOG(INFO, "dnsmasq: Lease file removed, flushing all entries.");
    }

    dhcps_lease_flush();
}


static struct dhcps_rip *dhcps_rip_node_new(void)
{
    struct dhcps_rip *rip;

    rip = calloc(1, sizeof(*rip));

    return rip;
}

static struct dhcps_rip *dhcps_rip_node_dup(const struct dhcps_rip *rip)
{
    struct dhcps_rip *rip_new;

    rip_new = dhcps_rip_node_new();
    if (!rip_new)
        return NULL;
    memcpy(rip_new, rip, sizeof(*rip));
    if (rip->ds_hostname)
        rip_new->ds_hostname = strdup(rip->ds_hostname);

    return rip_new;
}

static void dhcps_rip_node_free(struct dhcps_rip *rip)
{
    if (!rip)
        return;

    if (rip->ds_hostname)
        free(rip->ds_hostname);
    memset(rip, 0, sizeof(*rip));
    free(rip);
}


static int dhcps_rip_cmp(void *a, void *b)
{
    inet_macaddr_t *mac_a = (inet_macaddr_t *)a;
    inet_macaddr_t *mac_b = (inet_macaddr_t *)b;

    return memcmp(mac_a, mac_b, sizeof(*mac_a));
}


bool inet_dhcps_rip(inet_dhcps_t *self, inet_macaddr_t macaddr,
                    inet_ip4addr_t ip4addr, const char *hostname)

{
    struct dhcps_rip *rip = 0;

    rip = ds_tree_find(&self->ds_config_inactive.ds_rip_list, (void *)&macaddr);

    if (rip)
    {
        if (rip->ds_ip4addr.raw == ip4addr.raw)
        {
            if (rip->ds_hostname && hostname && !strcmp(rip->ds_hostname, hostname))
                return true;
            if (rip->ds_hostname == NULL && hostname == NULL)
                return true;
        }

        /* Modify existing IP reservation:  */
        rip->ds_macaddr = macaddr;
        rip->ds_ip4addr = ip4addr;
        if (hostname)
        {
            if (rip->ds_hostname)
                free(rip->ds_hostname);
            rip->ds_hostname = strdup(hostname);
        }
    }
    else
    {
        /* NEW IP reservation:  */
        rip = dhcps_rip_node_new();
        if (!rip)
            return false;

        rip->ds_macaddr = macaddr;
        rip->ds_ip4addr = ip4addr;
        if (hostname)
            rip->ds_hostname = strdup(hostname);
        else
            rip->ds_hostname = 0;

        ds_tree_insert(&self->ds_config_inactive.ds_rip_list, rip, &rip->ds_macaddr);
    }

    return true;
}

bool inet_dhcps_rip_remove(inet_dhcps_t *self, inet_macaddr_t macaddr)
{
    struct dhcps_rip *rip = 0;


    rip = ds_tree_find(&self->ds_config_inactive.ds_rip_list, (void *)&macaddr);
    if (rip)
    {
        ds_tree_remove(&self->ds_config_inactive.ds_rip_list, rip);
        dhcps_rip_node_free(rip);
    }

    return true;
}

bool inet_dhcps_rip_get(inet_dhcps_t *self, inet_macaddr_t macaddr,
                        inet_ip4addr_t *ip4addr, char **hostname)
{
    struct dhcps_rip *rip = 0;

    if (!ip4addr || !hostname)
        return false;


    rip = ds_tree_find(&self->ds_config_inactive.ds_rip_list, (void *)&macaddr);
    if (rip)
    {
        *ip4addr = rip->ds_ip4addr;
        if (rip->ds_hostname)
            *hostname = strdup(rip->ds_hostname);
        else
            *hostname = NULL;
    }
    else
    {
        *ip4addr = INET_IP4ADDR_ANY;
        *hostname = NULL;
    }

    return true;
}


